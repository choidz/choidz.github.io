# Elasticsearch 대용량 처리를 위한 JVM과 시스템 최적화

---

**​**

**Elasticsearch는 JVM 기반 애플리케이션으로, 힙 메모리를 32GB 이하로 설정하고 Compressed OOP를 활용해야 합니다. 메모리 스와핑을 비활성화하고, 파일 디스크립터와 스레드 한계를 높여 대용량 처리 성능을 극대화할 수 있습니다.**

---

**📋 목차**

  1. **JVM 힙 메모리 설정의 중요성**

  2. **32GB 제한의 기술적 배경**

  3. **메모리 스와핑 관리**

  4. **시스템 튜닝 포인트**

---

**1️⃣ JVM 힙 메모리 설정의 중요성**

**▪️ 기본 설정과 실제 운영의 차이**

**Elasticsearch 6버전 이상은 Java 1.8 이상을 필수로 요구합니다. JVM 위에서 실행되는 Elasticsearch는 기본적으로 1GB의 힙 메모리로 설정되어 있으나, 이는 최소 실행 크기일 뿐 실제 운영 환경에서는 훨씬 큰 크기로 변경해야 합니다.**

**Elasticsearch의 분산 시스템 특성상 Scale-up/Scale-Out이 빈번하고, 장애 복구 시 데이터 리밸런싱으로 많은 메모리를 사용하므로 JVM 튜닝은 필수입니다.**

**▪️ 최소 힙 크기와 최대 힙 크기 설정**

**JVM은****-Xms****(최소 힙 크기)로 시작하다가 필요시****-Xmx****(최대 힙 크기)까지 확장합니다. 이 과정에서 성능 저하가 발생할 수 있으므로, 운영 환경에서는 두 값을 동일하게 설정하는 것이 유리합니다.**

> 💡 권장 설정 예시: -Xms4G -Xmx4G

**너무 작은 힙은 OOM(Out of Memory) 오류를, 너무 큰 힙은 Full GC 발생 시 STW(Stop The World)를 유발하므로 균형이 중요합니다.**

---

**2️⃣ 32GB 제한의 기술적 배경**

**▪️ Compressed OOP와 Object Pointer**

**Elasticsearch에서 힙 크기를 32GB 이하로 권장하는 이유는 Hot-Spot JVM의 Object Pointer 정책 때문입니다. Object Pointer는 객체의 메모리 주소를 표현하는 값으로, 32비트 JVM과 64비트 JVM 모두 기본적으로 32비트 주소값을 사용합니다.**

**64비트 시스템에서 일반적인 OOP를 사용하면 포인터 표현에 64비트를 사용하여 메모리 낭비가 발생합니다. 이를 해결하기 위해 Java는****Compressed OOP****라는 기법을 도입했습니다.**

**▪️ Compressed OOP의 작동 원리**

**Compressed OOP는 포인터를 압축하여 표현함으로써 메모리 효율성을 높입니다. 객체의 정확한 메모리 주소 대신 상대적인 오브젝트 오프셋을 가리키도록 변형하여, 8비트 포인터로 더 큰 주소 공간을 표현할 수 있습니다.**

  * **32비트 OOP: 최대 4GB 메모리 주소 표현**

  * **32비트 Compressed OOP: 최대 32GB 메모리 주소 표현 (객체 단위 8바이트 기준)**

  * **64비트 OOP: 메모리 낭비로 인한 성능 저하**

**힙 크기가 32GB를 초과하면 JVM은 자동으로 Compressed OOP를 일반 OOP로 변환하여 32비트 주소값의 이점을 모두 잃게 됩니다.**

**▪️ Zero-Based Compressed OOP**

**최신 JVM은 힙 메모리의 시작 번지를 0번지부터 시작하도록 강제하는 Zero-Based Compressed OOP를 지원합니다. 이를 통해 추가 Add 연산 없이 시프트 연산만으로 포인터를 계산하여 성능을 더욱 향상시킵니다.**

**​**

**📌 Compressed OOP 설정 확인 명령어:**

---

**3️⃣ 메모리 스와핑 관리**

**▪️ 메모리 스와핑의 위험성**

**메모리 스와핑은 물리 메모리가 부족할 때 디스크의 일부를 메모리처럼 사용하는 기술입니다. 그러나 디스크 I/O는 메모리 접근보다 훨씬 느리므로 Elasticsearch 성능에 심각한 영향을 미칩니다.**

**Elasticsearch에서 스와핑이 발생하면 GC가 비정상적으로 수 분간 지속되거나, 클러스터 연결이 불안정하여 노드 간 연결이 끊어지는 현상이 반복될 수 있습니다.**

**▪️ 스와핑 비활성화**

**분산 시스템의 안정성을 위해 스와핑은 완전히 비활성화하는 것이 권장됩니다.**

**​**

**📌 일시적 스와핑 비활성화:**

**📌 영구적 비활성화:**

**▪️ 스와핑 최소화 설정**

**완전 비활성화가 불가능한 경우,****vm.swappiness****를 1로 설정하여 스와핑 발생을 최소화할 수 있습니다.**

**📌 swappiness 확인:**

**📌 임시 설정:**

**📌 영구 설정:**

**▪️ 애플리케이션 레벨 메모리 잠금**

**Elasticsearch 설정 파일에서****bootstrap.memory_lock: true****를 설정하면 애플리케이션이 할당받은 메모리를 스와핑하지 못하도록 강제합니다.**

**📌 elasticsearch.yml 수정:**

**📌 설정 확인:**

**설정이 실패한 경우 대부분 운영체제 리소스 제한이 원인입니다.****ulimit -l unlimited****로 해결할 수 있습니다.**

---

**4️⃣ 시스템 튜닝 포인트**

**▪️ 파일 디스크립터 한계 설정**

**Elasticsearch 노드는 클라이언트와의 통신을 위해 많은 수의 소켓을 사용하며, 내부의 Lucene은 인덱스 관리를 위해 수많은 파일을 생성합니다. 따라서 충분한 파일 디스크립터 할당이 필수입니다.**

**📌 현재 파일 디스크립터 확인:**

**📌 임시 설정:**

**📌 영구 설정:**

**📌 Elasticsearch API로 확인:**

**설정 오류가 발생하면 커널 레벨의 파일 한계를 확인하고 필요시 증가시켜야 합니다.**

**📌 커널 레벨 파일 한계 확인:**

**📌 커널 레벨 파일 한계 설정:**

**▪️ 스레드 한계 설정**

**Elasticsearch는 빠른 처리를 위해 스레드 풀을 활용하여 대량의 스레드를 관리합니다. 스레드 풀 내부의 스레드 수는 CPU 수를 기반으로 Elasticsearch가 자동 계산하므로, 사용자는 충분한 스레드 생성 권한만 확보하면 됩니다.**

**📌 현재 스레드 한계 확인:**

**📌 임시 설정:**

**📌 영구 설정:**

**📌 Elasticsearch API로 확인:**

**▪️ 가상 메모리 맵 설정**

**Elasticsearch 내부의 Lucene은 NIO 기술을 사용하여 운영체제 커널의 mmap 시스템콜을 직접 호출합니다. 이를 통해 커널 레벨의 파일 시스템 캐시를 활용하여 높은 성능을 낼 수 있습니다.**

**📌 현재 max_map_count 확인:**

**📌 임시 설정 (최소 262144 권장):**

**📌 영구 설정:**

**📌 설정 확인:**

**▪️ 메모리 할당 전략**

**Elasticsearch는 Lucene의 세그먼트 생성 및 관리를 위해 커널 시스템 캐시를 최대한 활용합니다. 따라서 물리 메모리의 약 50%를 운영체제와 Lucene을 위해 할당하고, 나머지 50%를 Elasticsearch 힙으로 설정하는 것이 최적입니다.**

**💡 전체 물리 메모리 32GB 기준:**

  * **Elasticsearch 힙: 16GB (최대 32GB 이하)**

  * **운영체제 및 Lucene 캐시: 16GB**

---

**#Elasticsearch #JVM튜닝 #메모리최적화 #CompressedOOP #시스템튜닝 #대용량처리 #스와핑 #파일디스크립터 #스레드풀 #분산시스템**

[원문 보기](https://blog.naver.com/choidz_/224072951289?fromRss=true&trackingCode=rss)
