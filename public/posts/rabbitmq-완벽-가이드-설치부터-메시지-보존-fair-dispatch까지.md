# RabbitMQ 완벽 가이드: 설치부터 메시지 보존, Fair Dispatch까지

---

**메시지 큐(Message Queue)는 현대적인 애플리케이션 아키텍처에서 빠질 수 없는 핵심 요소예요. 특히****RabbitMQ****는 안정적이고 확장 가능한 메시지 브로커로서 많은 기업에서 사용하고 있습니다. 하지만 단순히 설치하는 것만으로는 부족해요. 메시지가 손실되지 않도록 보존하는 방법, 여러 워커에게 공평하게 작업을 분배하는 방법까지 알아야 실무에서 제대로 활용할 수 있거든요.**

**이 글에서는 Windows 환경에서 RabbitMQ를 설치하는 과정부터 시작해서, 메시지 보존 설정, 그리고 여러 워커 간의 공평한 작업 분배(Fair Dispatch)까지 실무에 필요한 모든 내용을 다룰 거예요. 금융 거래처럼 중요한 메시지는 반드시 보존하고, 로그인 이벤트처럼 덜 중요한 메시지는 빠르게 처리하는 방식까지 배워볼 수 있습니다.**

---

**⚙️ RabbitMQ 설치: Windows 환경에서의 완벽한 셋업**

**RabbitMQ를 설치하기 전에 먼저 이해해야 할 점이 있어요. RabbitMQ는 Erlang이라는 프로그래밍 언어로 만들어져 있기 때문에, RabbitMQ를 실행하려면 반드시 Erlang이 먼저 설치되어 있어야 합니다. 이것이 많은 사람들이 놓치는 부분이에요.**

**1️⃣ Erlang 설치 및 환경변수 설정**

**첫 번째 단계는 Erlang을 설치하는 거예요.****http://erlang.org/****에 접속해서 자신의 OS 버전에 맞는 바이너리 설치파일을 다운로드합니다. Windows 환경이라면 .exe 파일을 받으면 되고, 설치 과정은 일반적인 프로그램 설치와 동일해요.**

![](/images/posts/rabbitmq-완벽-가이드-설치부터-메시지-보존-fair-dispatch까지-00-90fe12ad.png)

_**Erlang 공식 사이트에서 OS에 맞는 버전 선택**_

![](/images/posts/rabbitmq-완벽-가이드-설치부터-메시지-보존-fair-dispatch까지-01-d65d6fa8.png)

_**Erlang 설치 과정**_

**Erlang 설치가 완료되면 이제 환경변수를 설정해야 해요. Windows의 시스템 환경변수에****ERLANG_HOME****을 추가합니다. 이 변수의 값은 Erlang이 설치된 경로예요. 예를 들어 기본 설치 경로라면 C:\Program Files\erl-버전번호 같은 형태가 됩니다.****​**

![](/images/posts/rabbitmq-완벽-가이드-설치부터-메시지-보존-fair-dispatch까지-02-74877b1e.png)

_**ERLANG_HOME 환경변수 설정**_

**정리하자면, Erlang 설치 → ERLANG_HOME 환경변수 추가 이 두 단계가 RabbitMQ 설치의 기초가 되는 거죠.**

**2️⃣ RabbitMQ Server 설치**

**이제 본격적으로 RabbitMQ를 설치합니다. 중요한 점은****Server 버전****을 다운로드해야 한다는 거예요. Client 버전을 실수로 다운로드하면 메시지 브로커 역할을 할 수 없습니다.****http://www.rabbitmq.com/download.html****에서 Windows용 Server 설치파일을 받으세요.**

![](/images/posts/rabbitmq-완벽-가이드-설치부터-메시지-보존-fair-dispatch까지-03-bf4051e9.png)

_**RabbitMQ 공식 다운로드 페이지**_

![](/images/posts/rabbitmq-완벽-가이드-설치부터-메시지-보존-fair-dispatch까지-04-2fa380e1.png)

_**Windows용 RabbitMQ Server 선택 / RabbitMQ 설치 진행**_

**RabbitMQ 설치가 완료되면 Erlang과 마찬가지로 환경변수를 설정해야 합니다.****RABBITMQ_SERVER****라는 새로운 환경변수를 추가하고, 그 값을 RabbitMQ 설치 경로로 설정하세요. 기본 설치 경로는 C:\Program Files\RabbitMQ Server\rabbitmq_server-버전번호 형태예요.****​**

![](/images/posts/rabbitmq-완벽-가이드-설치부터-메시지-보존-fair-dispatch까지-05-d69a1de6.png)

_**RABBITMQ_SERVER 환경변수 설정**_

**마지막으로 Path 환경변수의 맨 뒤에**

 _**Path 환경변수에 RabbitMQ sbin 경로 추가**_

**3️⃣ 관리 플러그인 설치 및 서비스 시작**

**이제 RabbitMQ의 관리 플러그인을 설치해야 합니다. 이 플러그인을 설치하면 웹 기반의 관리 대시보드를 통해 Queue 상태를 모니터링할 수 있어요. Windows 커맨드 프롬프트를****관리자 권한****으로 열어서 다음 명령어들을 순서대로 실행하세요.**

**첫 번째 단계: 관리 플러그인 활성화**

**이 명령어를 실행하면 RabbitMQ의 관리 플러그인이 활성화됩니다. 성공적으로 완료되면 관리 대시보드에 접속할 수 있게 되죠.**

**두 번째 단계: RabbitMQ 서비스 중지**

**기존에 실행 중인 RabbitMQ 서비스를 중지합니다.**

**세 번째 단계: RabbitMQ 서비스 설치**

**RabbitMQ를 Windows 서비스로 등록합니다. 이렇게 하면 Windows 부팅 시 자동으로 RabbitMQ가 시작되어요.**

**네 번째 단계: RabbitMQ 서비스 시작**

**RabbitMQ 서비스를 시작합니다. 이제 RabbitMQ가 백그라운드에서 실행되고 있어요.**

**모든 설정이 완료되면 웹 브라우저에서****http://localhost:15672****에 접속할 수 있습니다. 기본 사용자명과 비밀번호는 guest/guest예요. 여기서 Queue 상태를 실시간으로 모니터링할 수 있죠.**

**⚠️ 주의할 점은 guest 계정은 localhost 장비에서만 접근 가능하다는 거예요. 외부 장비에서 RabbitMQ 서버에 접속해야 한다면 별도의 계정을 만들어야 합니다.**

**4️⃣ 외부 접근용 관리자 계정 생성**

**외부 장비에서 RabbitMQ에 접속하려면 새로운 사용자를 생성해야 해요. 관리자 권한의 커맨드 프롬프트에서 다음 명령어를 실행하세요.**

**이 명령어는 "admin"이라는 사용자를 생성하고 비밀번호를 "password"로 설정합니다. 물론 실제 운영 환경에서는 더 복잡한 비밀번호를 사용해야 해요.**

**이 명령어로 admin 사용자에게 관리자 권한을 부여합니다. 이제 admin 계정으로 외부에서 RabbitMQ 관리 대시보드에 접속할 수 있어요.**

---

**💾 메시지 보존 설정: 데이터 손실 방지하기**

**RabbitMQ를 설치했다고 해서 모든 게 끝나는 건 아니에요. 중요한 메시지가 손실되지 않도록 보존 설정을 해야 합니다. 특히 금융 거래 같은 중요한 비즈니스 로직과 관련된 메시지라면 반드시 디스크에 저장되어야 하죠.**

**Queue의 Durable 설정**

**기본적으로 RabbitMQ 서버가 종료되고 재기동하면, 생성되었던 모든 Queue는 제거됩니다. 이를 방지하려면 Queue를 생성할 때****Durable 옵션을 True로 설정****해야 해요. 이렇게 하면 RabbitMQ가 재시작되어도 Queue가 유지됩니다.**

**하지만 Queue가 유지된다고 해서 그 안의 메시지까지 유지되는 건 아니에요. 메시지 자체를 보존하려면 추가 설정이 필요합니다.**

**메시지의 delivery-mode 설정**

**메시지를 보존하기 위해서는 메시지 전송 시****PERSISTENT_TEXT_PLAIN****옵션을 사용해야 합니다.**

**내부적으로 메시지는****delivery-mode****라는 속성을 가지고 있어요. 이 값의 의미는 다음과 같습니다:**

  * **delivery-mode = 1 (기본값)****: 메시지가 메모리에서만 관리됩니다. RabbitMQ 서버가 종료되면 메시지가 손실돼요.**

  * **delivery-mode = 2****: RabbitMQ가 메시지를 디스크에 영속화시킵니다. 서버가 종료되어도 메시지가 보존돼요.**

**실무에서는 메시지의 중요도에 따라 이 값을 다르게 설정합니다. 금융 거래 이벤트처럼 비즈니스와 밀접하게 연관된 메시지는 delivery-mode를 2로 설정해서 반드시 보존하고, 로그인 이벤트처럼 비즈니스에 직접적인 영향을 주지 않는 메시지는 delivery-mode를 1로 설정해서 빠르게 처리하는 식이죠.**

**이렇게 구분하는 이유는 뭘까요? 디스크에 저장하는 작업은 메모리에서만 관리하는 것보다 훨씬 느리거든요. 따라서 정말 필요한 메시지만 디스크에 저장해서 전체 시스템의 성능을 최적화할 수 있는 거예요.**

**메시지 손실 방지: Acknowledgement(Ack) 설정**

**메시지 보존만큼 중요한 게 바로 메시지 손실 방지예요. RabbitMQ는 Consumer에게 전달된 메시지의 손실을 방지하기 위한 기능을 기본적으로 제공합니다.**

**이 메커니즘은 이렇게 작동해요: RabbitMQ가 Consumer에게 메시지를 전달한 후, Consumer가 작업을 완료했다는 응답(Acknowledgement, 줄여서 Ack)을 받지 못하면, 그 메시지를 다시 Queue에 집어넣고 다른 워커에게 전송합니다. 이렇게 하면 메시지가 처리되지 않고 손실되는 상황을 방지할 수 있어요.**

**이 기능은 기본적으로 활성화되어 있으므로 별도의 설정이 필요 없습니다. 더 자세한 내용은 공식 문서****https://www.rabbitmq.com/confirms.html****에서 확인할 수 있어요.**

---

**⚖️ Fair Dispatch: 여러 워커 간의 공평한 작업 분배**

**이제 실무에서 가장 중요한 부분에 도달했어요. RabbitMQ에서 메시지를 여러 워커에게 분배하는 방식을 이해하는 것은 시스템 성능을 크게 좌우합니다.**

**기본 Dispatch 방식: Round Robin의 문제점**

**RabbitMQ의 기본 dispatch 방식은****Round Robin(라운드 로빈)****이에요. 이는 MessageQueue에 담긴 순서대로 워커들에게 메시지를 하나씩 돌아가며 전달하는 방식입니다. 모든 워커가 동일한 속도로 작업을 처리한다면 이 방식이 충분할 수 있어요.**

**하지만 현실은 다릅니다. 예를 들어 Queue에 10개의 작업이 있고, 각 작업의 처리 시간이 다르다고 생각해봐요. 어떤 작업은 1초면 끝나지만, 어떤 작업은 10초가 걸릴 수 있죠. 이런 상황에서 Round Robin 방식으로 분배하면 어떻게 될까요?**

![](/images/posts/rabbitmq-완벽-가이드-설치부터-메시지-보존-fair-dispatch까지-06-28c94a12.png)

_**Prefetch Count 설정 없을 때: 한 워커가 무거운 작업을 처리하는 동안 다른 워커들은 대기**_

**Worker 1이 처리 시간이 긴 작업을 받으면, 그 작업을 처리하는 동안 Worker 2와 Worker 3은 놀고 있게 돼요. 이건 시스템 자원의 낭비이고, 전체 처리량(throughput)을 떨어뜨립니다. 이 문제를 해결하는 게 바로****Prefetch Count****라는 개념이에요.**

**Prefetch Count로 Fair Dispatch 구현하기**

**Prefetch Count****는 Consumer에게 보내는 메시지 수를 지정하는 옵션입니다. 더 정확히 말하면, Consumer가 RabbitMQ로부터 Acknowledgement(Ack)를 보내기 전까지 미리 받을 수 있는 메시지의 개수를 제한하는 거예요.**

**기본 설정 값은 무제한(unbounded)이에요. 즉, RabbitMQ가 Consumer에게 최대한 많은 메시지를 미리 전달합니다. 이렇게 하면 Consumer의 버퍼에 많은 메시지가 쌓이게 되고, 처리 시간이 긴 작업을 받은 워커는 그동안 다른 메시지들을 처리할 수 있어요. 하지만 이 방식은 다른 워커들이 일을 하지 못하고 대기하는 상황을 초래합니다.**

**Prefetch Count를 1로 설정하면 어떻게 될까요?**

![](/images/posts/rabbitmq-완벽-가이드-설치부터-메시지-보존-fair-dispatch까지-07-3010746e.png)

_**Prefetch Count = 1: 한 번에 하나의 메시지만 받아서 처리 후 다음 메시지 요청**_

**Prefetch Count를 1로 설정하면, 각 Consumer는 한 번에 하나의 메시지만 받습니다. Consumer가 그 메시지를 처리하고 Ack를 보낸 후에야 다음 메시지를 받을 수 있어요. 이렇게 하면:**

  * **전송된 메시지는 Consumer의 버퍼(Prefetch Buffer)에 캐시됩니다.**

  * **Prefetch된 메시지는 MessageQueue의 대기열에서 제거되고 다른 Consumer에게는 표시되지 않습니다.**

  * **Consumer가 메시지를 처리하고 Ack를 보낼 때까지 다음 메시지는 Queue에 남아있습니다.**

**결과적으로 여러 워커에게 작업이 공평하게 분배돼요. 처리 시간이 긴 작업을 받은 워커가 그것을 처리하는 동안, 다른 워커들은 Queue에 있는 다른 메시지들을 받아서 처리할 수 있게 되는 거죠.**

**Prefetch Count 설정 방법**

**RabbitMQ의 설정 파일에서 기본 Prefetch Count를 지정할 수 있어요. 설정 파일에 다음과 같은 설정을 추가합니다:**

**이 설정값을 조정함으로써 시스템의 특성에 맞는 최적의 분배 방식을 구현할 수 있어요.**

---

**🎯 Prefetch Count 값에 따른 성능 최적화**

**Prefetch Count를 어떤 값으로 설정할지는 시스템의 특성에 따라 달라져요. 이것이 바로 RabbitMQ를 제대로 활용하는 핵심이에요.**

**Prefetch Count = 1 (작은 값)일 때**

**장점:**

  * **여러 워커에게 작업이 공평하게 분배됩니다.**

  * **처리 시간이 긴 작업이 있어도 다른 워커들이 계속 일할 수 있어요.**

  * **특히 워커가 많거나 한 작업 단위의 처리 시간이 긴 경우에 효과적입니다.**

**단점:**

  * **각 워커가 하나의 메시지를 처리한 후 다음 메시지를 받을 때까지 대기시간이 발생할 수 있어요.**

  * **각 단위 요청이 빨리 처리되는 경우, 이 대기시간이 누적되어 전체 처리량이 떨어질 수 있습니다.**

**추천 상황:****워커가 많거나, 한 작업 단위의 처리 시간이 긴 경우. 예를 들어 이미지 처리, 동영상 인코딩, 복잡한 데이터 분석 같은 작업이 해당돼요.**

**Prefetch Count를 크게 설정했을 때**

**장점:**

  * **메시지 큐에서 다량의 메시지를 하나의 워커에게 미리 전달하므로, 각 워커의 대기시간이 줄어듭니다.**

  * **워커가 계속 일할 수 있어서 처리량이 증가해요.**

  * **특히 워커가 적고 한 작업 단위의 처리 시간이 짧은 경우에 효과적입니다.**

**단점:**

  * **특정 요청의 처리 시간이 긴 경우, 그 요청 때문에 다른 워커들이 일을 하지 못하고 대기할 수 있어요.**

  * **불공평한 작업 분배가 발생할 수 있습니다.**

**추천 상황:****워커가 적고, 한 작업 단위의 처리 시간이 짧은 경우. 예를 들어 간단한 로그 기록, 이메일 발송, 캐시 업데이트 같은 작업이 해당돼요.**

**실무에서의 최적화 전략**

**실제로는 시스템의 특성을 파악하고 여러 번의 테스트를 통해 최적의 Prefetch Count 값을 찾아야 해요. 다음과 같은 단계로 진행하면 됩니다:**

  1. **현재 시스템 분석:****워커의 개수, 평균 작업 처리 시간, 작업의 다양성 등을 파악합니다.**

  2. **초기값 설정:****워커 개수와 작업 특성에 따라 초기 Prefetch Count를 설정합니다.**

  3. **성능 모니터링:****처리량(throughput), 응답시간, CPU/메모리 사용률 등을 측정합니다.**

  4. **값 조정:****성능 지표를 바탕으로 Prefetch Count를 조정합니다.**

  5. **반복:****최적의 값을 찾을 때까지 3~4번 단계를 반복합니다.**

**RabbitMQ의 관리 대시보드(http://localhost:15672)에서 Queue의 상태를 실시간으로 모니터링할 수 있으니, 이를 활용해서 최적화 과정을 진행하면 좋아요.**

---

**🔍 실무 팁: RabbitMQ 운영 노하우**

**마지막으로 RabbitMQ를 실무에서 운영할 때 알아두면 좋은 팁들을 정리해봤어요.**

**1\. 메시지 우선순위 설정**

**금융 거래처럼 중요한 메시지와 로그 기록처럼 덜 중요한 메시지를 구분해서 처리할 수 있어요. delivery-mode를 다르게 설정하거나, 별도의 Queue를 만들어서 관리하는 방식이 있습니다.**

**2\. Dead Letter Queue 활용**

**처리에 실패한 메시지를 따로 모아두는 Dead Letter Queue를 설정하면, 나중에 이 메시지들을 분석하고 재처리할 수 있어요. 이는 시스템의 안정성을 크게 높입니다.**

**3\. 정기적인 모니터링**

**Queue의 길이, 메시지 처리 속도, 워커의 상태 등을 정기적으로 모니터링하세요. 문제가 발생했을 때 빠르게 대응할 수 있어요.**

**4\. 버전 관리**

**RabbitMQ와 Erlang의 버전 호환성을 항상 확인하세요. 특정 RabbitMQ 버전은 특정 Erlang 버전에서만 작동합니다.**

**5\. 클러스터링 고려**

**시스템이 커지면 RabbitMQ를 여러 대의 서버에 클러스터로 구성하는 것을 고려해봐요. 이렇게 하면 고가용성과 확장성을 확보할 수 있습니다.**

---

**📝 마치며**

**RabbitMQ는 단순한 메시지 브로커가 아니라, 시스템의 안정성과 성능을 크게 좌우하는 중요한 컴포넌트예요. 설치는 물론이고, 메시지 보존, Fair Dispatch 등의 개념을 제대로 이해하고 구현해야만 실무에서 제대로 활용할 수 있습니다.**

**특히 Prefetch Count 설정은 시스템의 특성에 따라 달라지기 때문에, 처음부터 완벽하게 설정하기는 어려워요. 하지만 모니터링을 통해 지속적으로 최적화하다 보면, 결국 자신의 시스템에 맞는 최적의 설정을 찾을 수 있을 거예요.**

**이 글에서 다룬 내용들이 여러분의 RabbitMQ 운영에 도움이 되길 바랍니다. 혹시 궁금한 점이나 추가로 알고 싶은 내용이 있다면, 공식 문서(https://www.rabbitmq.com/)를 참고하는 것도 좋은 방법이에요. 행운을 빕니다! 🚀**

**#RabbitMQ #메시지큐 #MessageQueue #Erlang #FairDispatch #PrefetchCount #메시지보존 #Windows설치**

[원문 보기](https://blog.naver.com/choidz_/224120360645?fromRss=true&trackingCode=rss)
