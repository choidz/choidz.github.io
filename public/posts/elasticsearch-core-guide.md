# 📌 Elasticsearch 핵심 개념 정리

---

## 📌 Elasticsearch ↔ RDBMS 비교

클러스터(= 192.168.20.5)  
└─ 노드: 1개 (MSSQL 인스턴스에 해당)  
　　├─ 인덱스: company_db  
　　├─ 인덱스: company_mes  
　　└─ 인덱스: company_mes_dev

| 개념                   | Elasticsearch                            | MSSQL (RDBMS)                               |
| -------------------- | ---------------------------------------- | ------------------------------------------- |
| **Cluster**          | 여러 노드(서버)들의 집합. 하나의 거대한 검색 시스템처럼 동작      | SQL Server 클러스터(AlwaysOn, Failover Cluster) |
| **Node**             | 클러스터를 구성하는 개별 서버 (마스터, 데이터, 코디네이팅, 인제스트) | DB 서버 인스턴스                                  |
| **Index**            | 논리적인 데이터베이스(Database)                    | Database (ex. COMPANY_DB)                   |
| **Document**         | JSON 형식의 개별 데이터 객체                       | Row (테이블의 한 행)                              |
| **Field**            | 문서의 속성 (JSON key)                        | Column (열)                                  |
| **Mapping**          | 문서 구조 정의 (필드 타입, 분석기 설정 등)               | Schema (테이블의 열 타입 정의, 제약조건)                 |
| **Shard**            | 인덱스를 물리적으로 나눈 조각. 프라이머리+레플리카 있음          | Partition (수평 파티셔닝과 유사)                     |
| **Replica**          | 샤드 복제본. 장애 시 failover + 검색 성능 향상         | Database Mirroring / AlwaysOn Replica       |
| **SQL**              | Elasticsearch DSL(Query DSL, JSON 기반)    | SELECT, INSERT, UPDATE, DELETE              |
| **Transaction**      | 없음 (분산 검색 최적화용)                          | 지원 (ACID 보장)                                |
| **Join**             | 제한적 (nested, parent-child 관계만)           | 자유로운 JOIN 지원                                |
| **Stored Procedure** | 없음                                       | 지원                                          |
| **Indexing**         | 문서를 분석 → 역색인 구조(Inverted Index)에 저장      | 인덱스(B-Tree, Hash 등) 구조에 저장                  |

---

## 1. 클러스터와 노드

- **클러스터**: 여러 대의 서버(노드)가 모여 하나의 검색 시스템처럼 동작.
    
    - 어떤 노드에 요청을 보내도 동일한 결과를 받을 수 있음.
        
- **노드(Node) 역할**:
    
    - **마스터 노드**: 클러스터 관리 (인덱스 생성, 노드 관리).
        
    - **데이터 노드**: 실제 문서 저장, 검색/색인 처리.
        
    - **코디네이팅 노드**: 클라이언트 요청을 받아 적절히 분산.
        
    - **인제스트 노드**: 색인 전 데이터 변환/전처리.
        

---

## 2. 인덱스 (Index)

- 문서(Document)를 저장하는 **논리적인 공간**.
    
- 설계 방법:
    
    - 하나의 큰 인덱스 → 관리 간단, 대용량 단일 집합.
        
    - 여러 인덱스 분리 → 로그, 날짜별 데이터, 다중 서비스 환경에 적합.
        

---

## 3. 샤드 (Shard)

- 인덱스를 실제 물리적으로 쪼개서 저장하는 단위.
    

### 종류

- **프라이머리 샤드**: 원본 데이터 저장, 색인/검색 성능에 직접 영향.
    
- **레플리카 샤드**: 프라이머리 샤드 복제본. 장애 시 승계 + 검색 부하 분산.
    

### 라우팅 규칙

- `문서ID % 샤드 개수`
    
- **프라이머리 샤드 개수는 인덱스 생성 후 변경 불가.**
    
- **레플리카 개수는 변경 가능.**
    

---

## 4. 매핑 (Mapping)

- **RDBMS의 스키마와 유사**.
    
- 데이터 구조(필드명, 타입, 분석기 등)를 정의.
    

### 종류

- **동적 매핑**: 문서가 들어오면 자동 생성. 편리하지만 타입 오류 발생 가능.
    
- **정적 매핑**: 미리 정의. 안전하고 일관성 유지.
    
- → 보통 **정적 매핑 + 필요한 경우 동적 매핑 보완** 형태 사용.
    

---

## 5. 색인 (Indexing) 과정

### 색인 단계

1. 인덱스 확인 (없으면 생성).
    
2. 매핑 확인 (없으면 동적 매핑 생성).
    
3. 문서 분석 (Analyzer) → 토큰 생성.
    
4. 역색인(Inverted Index) 생성.
    
5. 프라이머리 샤드에 저장.
    
6. 레플리카 샤드 복제.
    

---

## 6. 검색 (Search) 과정

### 검색 흐름

1. 검색어 분석 (Analyzer 적용 → 토큰 생성).
    
2. Inverted Index에서 토큰 검색.
    
3. 결과 점수/필터 적용 후 반환.
    

### 역색인 (Inverted Index)

- **단어 → 문서 목록** 구조.
    
- 예:
    
    `"서울" → [Doc1, Doc5, Doc9] "삼성" → [Doc2, Doc5] "전자" → [Doc2, Doc7]`
    
- RDBMS의 B-Tree 인덱스와 달리 **텍스트 검색 최적화** 구조.
    

### Analyzer (분석기)

- Character Filter → Tokenizer → Token Filter 순서로 문자열을 토큰화.
    
- 예: `"Hello, World!"` → `["hello
